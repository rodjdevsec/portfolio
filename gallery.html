<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rogel's Gallery</title>
    <link rel="icon" type="image/svg+xml"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='25' fill='%23000000'/><text x='50%25' y='55%25' dominant-baseline='middle' text-anchor='middle' fill='%23FFFFFF' font-family='Arial, sans-serif' font-weight='900' font-size='60'>R</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500&family=Playfair+Display:ital,wght@0,400;0,600;1,400&display=swap');

        .slide-content {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.8s ease, transform 0.8s ease-out;
        }

        .slide-content.active {
            opacity: 1;
            transform: translateY(0);
        }

        #gallery-splash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 200;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 1.5s cubic-bezier(0.4, 0, 0.2, 1), visibility 1.5s;
        }

        #gallery-splash.fade-out {
            opacity: 0;
            visibility: hidden;
        }

        .splash-text {
            font-size: 11px;
            font-weight: 300;
            text-transform: uppercase;
            letter-spacing: 12px;
            color: #fff;
            text-align: center;
            opacity: 0;
            transform: translateY(10px);
            animation: splash-entry 3s forwards ease-out;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        @keyframes splash-entry {
            0% {
                opacity: 0;
                filter: blur(10px);
                transform: translateY(20px) scale(0.95);
                letter-spacing: 4px;
            }

            40% {
                opacity: 1;
                filter: blur(0);
                transform: translateY(0) scale(1);
                letter-spacing: 12px;
            }

            70% {
                opacity: 1;
                filter: blur(0);
                transform: translateY(0) scale(1);
                letter-spacing: 12px;
            }

            100% {
                opacity: 0.8;
                filter: blur(0);
                transform: translateY(-2px) scale(1.01);
                letter-spacing: 14px;
            }
        }

        #gallery-controls {
            position: fixed;
            bottom: 30px;
            left: 24px;
            z-index: 100;
            display: none;
            flex-direction: row;
            gap: 24px;
            align-items: center;
        }

        .control-btn {
            color: rgba(255, 255, 255, 0.4);
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: none;
            border-top: none;
            border-left: none;
            border-right: none;
        }

        .control-btn:active {
            opacity: 0.5;
        }

        @media (max-width: 768px) {
            #gallery-controls {
                display: flex;
            }
        }
    </style>
</head>

<body class="bg-black text-white font-['Inter'] m-0 p-0 w-full h-full overflow-hidden">

    <div id="gallery-splash">
        <div class="splash-text">Scroll to explore</div>
    </div>



    <nav
        class="fixed top-0 left-0 w-full z-[90] flex justify-between items-center px-6 py-6 md:px-12 md:py-8 pointer-events-none">
        <div></div>

        <a href="about"
            class="pointer-events-auto group flex items-center gap-2 text-[10px] font-bold uppercase tracking-[0.3em] text-white/50 hover:text-white transition-colors">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"
                stroke-linecap="round" stroke-linejoin="round" class="group-hover:-translate-x-1 transition-transform">
                <path d="M19 12H5"></path>
                <path d="M12 19l-7-7 7-7"></path>
            </svg>
            Back
        </a>
    </nav>

    <div id="canvas-container" class="fixed top-0 left-0 w-full h-full z-[1]"></div>

    <div id="ui-layer" class="fixed top-0 left-0 w-full h-full z-[2] pointer-events-none">
        <!-- Dynamic slides will be injected here -->
    </div>

    <div
        class="scroll-hint fixed bottom-5 md:bottom-10 left-0 md:left-[50px] w-full md:w-auto text-center md:text-left text-[0.7rem] uppercase tracking-[2px] text-[#aaa]">
        Scroll to explore</div>

    <div id="gallery-controls">
        <button id="calibrate-btn" class="control-btn" aria-label="Recalibrate Center">
            <span>Recalibrate</span>
        </button>
        <button id="gyro-toggle-btn" class="control-btn" aria-label="Toggle Gyroscope">
            <span>Gyro Off</span>
        </button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script type="module">
        import { gallery as initialGallery } from './js/data.js';

        // Load from localStorage if available, otherwise use initial data
        const gallery = JSON.parse(localStorage.getItem('portfolio_gallery')) || initialGallery;

        let isMobile = window.innerWidth <= 768;
        let CONFIG = {};
        let totalGalleryWidth = 0;
        let paintingGroups = [];
        let galleryGroup = null;
        let camera = null;

        function updateConfig() {
            isMobile = window.innerWidth <= 768;
            CONFIG = {
                slideCount: gallery.length,
                spacingX: isMobile ? 35 : 45,
                pWidth: isMobile ? 12 : 14,
                pHeight: isMobile ? 15 : 18,
                camZ: isMobile ? 38 : 30,
                wallAngleY: isMobile ? 0 : -0.25,
                snapDelay: 200,
                lerpSpeed: 0.06
            };
            totalGalleryWidth = CONFIG.slideCount * CONFIG.spacingX;

            if (galleryGroup) {
                galleryGroup.rotation.y = CONFIG.wallAngleY;
                galleryGroup.position.x = isMobile ? 0 : 8;
                galleryGroup.position.y = isMobile ? 6 : 0;

                paintingGroups.forEach((group, i) => {
                    group.position.x = i * CONFIG.spacingX;
                });
            }

            if (camera) {
                camera.position.z = CONFIG.camZ;
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            }
        }

        function renderUISlides() {
            const uiLayer = document.getElementById('ui-layer');
            uiLayer.innerHTML = gallery.map((item, i) => `
                <div class="slide-content absolute pointer-events-auto w-[90%] md:w-[30%] md:max-w-[450px] left-[5%] md:left-[8%] bottom-[10%] md:bottom-auto md:top-[35%] flex flex-col items-start md:items-start text-left md:text-left"
                    id="slide-${i}">
                    <span class="text-[0.7rem] uppercase tracking-[3px] text-[#666] mb-6 inline-block border-b border-[#333] pb-[5px]">
                        ${String(i + 1).padStart(2, '0')} / ${item.title}
                    </span>
                    <div class="font-['Inter'] text-[0.85rem] md:text-[0.9rem] font-light leading-[1.6] md:leading-[1.8] text-[#888] mb-8 md:mb-12 text-left md:text-justify tracking-wide">
                        ${item.description}
                    </div>
                    <div class="grid grid-cols-2 md:grid-cols-[80px_1fr] gap-2 md:gap-y-[0.8rem] border-t border-[#333] pt-4 md:pt-[1.5rem] w-full">
                        <span class="text-[0.6rem] uppercase tracking-[2px] text-[#555] self-center text-left md:text-left pr-4 md:pr-0">Location</span>
                        <span class="text-[0.75rem] md:text-[0.9rem] font-medium text-white text-left">${item.location}</span>

                        <span class="text-[0.6rem] uppercase tracking-[2px] text-[#555] self-center text-left md:text-left pr-4 md:pr-0">Date</span>
                        <span class="text-[0.75rem] md:text-[0.9rem] font-medium text-white text-left">${item.date}</span>

                        <span class="text-[0.6rem] uppercase tracking-[2px] text-[#555] self-center text-left md:text-left pr-4 md:pr-0">Device</span>
                        <span class="text-[0.75rem] md:text-[0.9rem] font-medium text-white text-left">${item.device}</span>
                    </div>
                </div>
            `).join('');
        }

        updateConfig();
        renderUISlides();

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.Fog(0x000000, 10, 110);

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, CONFIG.camZ);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        galleryGroup = new THREE.Group();
        scene.add(galleryGroup);

        updateConfig();

        const textureLoader = new THREE.TextureLoader();
        const planeGeo = new THREE.PlaneGeometry(CONFIG.pWidth, CONFIG.pHeight);

        gallery.forEach((item, i) => {
            const group = new THREE.Group();
            group.position.set(i * CONFIG.spacingX, 0, 0);
            const mat = new THREE.MeshBasicMaterial({ map: textureLoader.load(item.image) });
            const mesh = new THREE.Mesh(planeGeo, mat);
            const edges = new THREE.EdgesGeometry(planeGeo);
            const outline = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x444444 }));

            const shadowGeo = new THREE.PlaneGeometry(CONFIG.pWidth, CONFIG.pHeight);
            const shadowMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.05 });
            const shadow = new THREE.Mesh(shadowGeo, shadowMat);
            shadow.position.set(0.8, -0.8, -0.5);

            const lineZ = -1;
            const lineLen = CONFIG.spacingX;
            const lineGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-lineLen / 2, 14, lineZ), new THREE.Vector3(lineLen / 2, 14, lineZ),
                new THREE.Vector3(-lineLen / 2, -14, lineZ), new THREE.Vector3(lineLen / 2, -14, lineZ)
            ]);
            const lines = new THREE.LineSegments(lineGeo, new THREE.LineBasicMaterial({ color: 0x333333 }));

            group.add(shadow);
            group.add(mesh);
            group.add(outline);
            group.add(lines);

            galleryGroup.add(group);
            paintingGroups.push(group);
        });

        galleryGroup.rotation.y = CONFIG.wallAngleY;
        galleryGroup.position.x = isMobile ? 0 : 8;
        galleryGroup.position.y = isMobile ? 6 : 0;

        let currentScroll = 0;
        let targetScroll = 0;
        let snapTimer = null;
        let mouse = { x: 0, y: 0 };

        function snapToNearest() {
            const index = Math.round(targetScroll / CONFIG.spacingX);
            targetScroll = index * CONFIG.spacingX;
        }

        window.addEventListener('wheel', (e) => {
            targetScroll += e.deltaY * 0.1;
            if (snapTimer) clearTimeout(snapTimer);
            snapTimer = setTimeout(snapToNearest, CONFIG.snapDelay);
        });

        let touchStart = 0;
        window.addEventListener('touchstart', e => {
            touchStart = e.touches[0].clientX;
            if (snapTimer) clearTimeout(snapTimer);
        });

        window.addEventListener('touchmove', e => {
            const diff = touchStart - e.touches[0].clientX;
            targetScroll += diff * 0.6;
            touchStart = e.touches[0].clientX;
            if (snapTimer) clearTimeout(snapTimer);
        });

        window.addEventListener('touchend', () => {
            snapToNearest();
        });

        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        let gyroEnabled = true;
        let initialOrientation = null;

        function toggleGyro(e) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            gyroEnabled = !gyroEnabled;
            const btn = document.getElementById('gyro-toggle-btn');
            btn.querySelector('span').innerText = gyroEnabled ? 'Gyro Off' : 'Gyro On';

            if (!gyroEnabled) {
                mouse.x = 0;
                mouse.y = 0;
                initialOrientation = null;
            }
        }

        function calibrate(e) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            initialOrientation = null;
            // Immediate feedback: center the view
            mouse.x = 0;
            mouse.y = 0;
        }

        document.getElementById('calibrate-btn').addEventListener('click', calibrate);
        document.getElementById('gyro-toggle-btn').addEventListener('click', toggleGyro);

        function handleOrientation(event) {
            if (!gyroEnabled) return;
            if (event.gamma === null || event.beta === null) return;

            if (!initialOrientation) {
                initialOrientation = {
                    gamma: event.gamma,
                    beta: event.beta
                };
                return;
            }

            let gammaDelta = event.gamma - initialOrientation.gamma;
            let betaDelta = event.beta - initialOrientation.beta;

            let x = gammaDelta / 20;
            let y = betaDelta / 20;

            mouse.x = Math.max(-2, Math.min(2, x));
            mouse.y = Math.max(-2, Math.min(2, y));
        }

        function startExperience() {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                        }
                    })
                    .catch(console.error);
            } else {
                window.addEventListener('deviceorientation', handleOrientation);
                window.addEventListener('deviceorientationabsolute', handleOrientation);
            }

            window.removeEventListener('click', startExperience);
            window.removeEventListener('touchstart', startExperience);
        }

        window.addEventListener('click', startExperience);
        window.addEventListener('touchstart', startExperience);

        // Auto-fade splash screen after 2.5 seconds
        setTimeout(() => {
            const splash = document.getElementById('gallery-splash');
            if (splash) splash.classList.add('fade-out');
        }, 2500);

        function updateUI(scrollX) {
            const rawIndex = Math.round(scrollX / CONFIG.spacingX);
            const safeIndex = ((rawIndex % CONFIG.slideCount) + CONFIG.slideCount) % CONFIG.slideCount;
            for (let i = 0; i < CONFIG.slideCount; i++) {
                const el = document.getElementById(`slide-${i}`);
                if (el) {
                    if (i === safeIndex) el.classList.add('active');
                    else el.classList.remove('active');
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            currentScroll += (targetScroll - currentScroll) * CONFIG.lerpSpeed;
            const xMove = currentScroll * Math.cos(CONFIG.wallAngleY);
            const zMove = currentScroll * Math.sin(CONFIG.wallAngleY);
            camera.position.x = xMove;
            camera.position.z = CONFIG.camZ - zMove;
            paintingGroups.forEach((group, i) => {
                const originalX = i * CONFIG.spacingX;
                const distFromCam = currentScroll - originalX;
                const shift = Math.round(distFromCam / totalGalleryWidth) * totalGalleryWidth;
                group.position.x = originalX + shift;
            });

            const rotationIntensity = isMobile ? 0.2 : 0.05;
            camera.rotation.x = -mouse.y * rotationIntensity;
            camera.rotation.y = mouse.x * rotationIntensity;

            updateUI(currentScroll);
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            updateConfig();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>

</html>